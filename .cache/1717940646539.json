{"date":"2024-06-09T13:44:04.405Z","courseId":"17","assignment":"AP-Spring03-CA6-phase3","trace":{"version":3,"content":"#include \"server.hpp\"\n\n#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include <algorithm>\n#include <fstream>\n#include <iostream>\n#include <map>\n#include <sstream>\n\n#include \"../utils/strutils.hpp\"\n#include \"../utils/utilities.hpp\"\n\n#ifdef _WIN32\n#ifndef _WIN32_WINNT\n#define _WIN32_WINNT 0x0501 // win xp\n#endif\n#include <Ws2tcpip.h>\n#include <winsock2.h>\n#else\n// POSIX sockets\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h> //close()\n#endif\n\n#ifdef _WIN32\n#define ISVALIDSOCKET(s) ((s) != INVALID_SOCKET)\n#define CLOSESOCKET(s)   closesocket(s)\n#define GETSOCKETERRNO() (WSAGetLastError())\n#else\n#define ISVALIDSOCKET(s) ((s) >= 0)\n#define CLOSESOCKET(s)   close(s)\n#define GETSOCKETERRNO() (errno)\n#endif\n\nstatic const char* getSocketError() {\n#ifdef _WIN32\n    static char message[256];\n    message[0] = '\\0';\n    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n                   NULL, WSAGetLastError(), 0, (LPSTR)&message, sizeof(message),\n                   NULL);\n    char* newline = strrchr(message, '\\n');\n    if (newline)\n        *newline = '\\0';\n    return message;\n#else\n    return strerror(errno);\n#endif\n}\n\nusing namespace std;\n\nclass NotFoundHandler : public RequestHandler {\npublic:\n    NotFoundHandler(const string& notFoundErrPage = \"\")\n        : notFoundErrPage_(notFoundErrPage) {}\n    Response* callback(Request* req) {\n        Response* res = new Response(Response::Status::notFound);\n        if (!notFoundErrPage_.empty()) {\n            res->setHeader(\"Content-Type\", \"text/\" + utils::getExtension(notFoundErrPage_));\n            res->setBody(utils::readFile(notFoundErrPage_));\n        }\n        return res;\n    }\n\nprivate:\n    string notFoundErrPage_;\n};\n\nclass ServerErrorHandler {\npublic:\n    static Response* callback(const string& msg) {\n        Response* res = new Response(Response::Status::internalServerError);\n        res->setHeader(\"Content-Type\", \"application/json\");\n        res->setBody(\"{ \\\"code\\\": \\\"500\\\", \\\"message\\\": \\\"\" + msg + \"\\\" }\\n\");\n        return res;\n    }\n};\n\nRequest* parseRawReq(char* reqData, size_t length) {\n    Request* req = nullptr;\n    string boundary;\n    string lastFieldKey;\n    string lastFieldValue;\n    string reqDataStr(reqData, reqData + length);\n    try {\n        size_t endOfHeader = reqDataStr.find(\"\\r\\n\\r\\n\");\n        string reqHeader = reqDataStr.substr(0, endOfHeader);\n        string reqBody = reqDataStr.substr(endOfHeader + 4, reqDataStr.size());\n        if (endOfHeader == string::npos) {\n            throw Server::Exception(\"End of request header not found.\");\n        }\n        vector<string> headers = strutils::split(reqHeader, \"\\r\\n\");\n        if (reqHeader.find('\\0') != string::npos) {\n            throw Server::Exception(\"Binary data in header.\");\n        }\n        size_t realBodySize = length - endOfHeader - 4; // string(\"\\r\\n\\r\\n\").size();\n\n        vector<string> R = strutils::split(headers[0], ' ');\n        if (R.size() != 3) {\n            throw Server::Exception(\"Invalid header (request line)\");\n        }\n        req = new Request(R[0]);\n        req->setPath(R[1]);\n        size_t pos = req->getPath().find('?');\n        if (pos != string::npos && pos != req->getPath().size() - 1) {\n            vector<string> Q1 = strutils::split(req->getPath().substr(pos + 1), '&');\n            for (vector<string>::size_type q = 0; q < Q1.size(); q++) {\n                vector<string> Q2 = strutils::split(Q1[q], '=');\n                if (Q2.size() == 2)\n                    req->setQueryParam(Q2[0], Q2[1], false);\n                else\n                    throw Server::Exception(\"Invalid query\");\n            }\n        }\n        req->setPath(req->getPath().substr(0, pos));\n\n        for (size_t headerIndex = 1; headerIndex < headers.size(); headerIndex++) {\n            string line = headers[headerIndex];\n            vector<string> R = strutils::split(line, \": \");\n            if (R.size() != 2)\n                throw Server::Exception(\"Invalid header\");\n            req->setHeader(R[0], R[1], false);\n            if (strutils::tolower(R[0]) == strutils::tolower(\"Content-Length\"))\n                if (realBodySize != (size_t)atol(R[1].c_str()))\n                    return nullptr;\n        }\n\n        string contentType = req->getHeader(\"Content-Type\");\n        if (realBodySize != 0 && !contentType.empty()) {\n            if (strutils::startsWith(contentType, \"application/x-www-form-urlencoded\")) {\n                vector<string> urlencodedParts = strutils::split(reqBody, \"\\r\\n\");\n                for (const string& part : urlencodedParts) {\n                    vector<string> body = strutils::split(part, '&');\n                    for (size_t i = 0; i < body.size(); i++) {\n                        vector<string> field = strutils::split(body[i], '=');\n                        if (field.size() == 2)\n                            req->setBodyParam(field[0], field[1], \"application/x-www-form-urlencoded\", false);\n                        else if (field.size() == 1)\n                            req->setBodyParam(field[0], \"\", \"application/x-www-form-urlencoded\", false);\n                        else\n                            throw Server::Exception(\"Invalid body\");\n                    }\n                }\n            }\n            else if (strutils::startsWith(contentType, \"multipart/form-data\")) {\n                boundary = contentType.substr(contentType.find(\"boundary=\") + 9);\n                size_t firstBoundary = reqBody.find(\"--\" + boundary);\n                if (firstBoundary == string::npos) {\n                    throw Server::Exception(\"Boundary data not found.\");\n                }\n                reqBody.erase(reqBody.begin(), reqBody.begin() + firstBoundary + 2 + boundary.size());\n\n                vector<string> boundaries = strutils::split(reqBody, \"--\" + boundary);\n                boundaries.pop_back();\n\n                for (string b : boundaries) {\n                    b.pop_back(); // remove \"\\r\\n\" from start and end of each boundary\n                    b.pop_back();\n                    b.erase(b.begin(), b.begin() + 2);\n                    string boundaryContentType = \"text/plain\";\n\n                    size_t endOfBoundaryHeader = b.find(\"\\r\\n\\r\\n\") + 4;\n                    vector<string> abc = strutils::split(b.substr(0, endOfBoundaryHeader - 4), \"\\r\\n\");\n                    for (const string& line : abc) {\n                        if (line.empty()) {\n                            break;\n                        }\n                        vector<string> R = strutils::split(line, \": \");\n                        if (R.size() != 2) throw Server::Exception(\"Invalid header\");\n                        if (strutils::tolower(R[0]) == strutils::tolower(\"Content-Disposition\")) {\n                            vector<string> A = strutils::split(R[1], \"; \");\n                            for (size_t i = 0; i < A.size(); i++) {\n                                vector<string> attr = strutils::split(A[i], '=');\n                                if (attr.size() == 2) {\n                                    if (strutils::tolower(attr[0]) == strutils::tolower(\"name\")) {\n                                        lastFieldKey = attr[1].substr(1, attr[1].size() - 2);\n                                    }\n                                }\n                                else if (attr.size() != 1) {\n                                    throw Server::Exception(\"Invalid body attribute\");\n                                }\n                            }\n                        }\n                        else if (strutils::tolower(R[0]) == strutils::tolower(\"Content-Type\")) {\n                            boundaryContentType = strutils::tolower(R[1]);\n                        }\n                    }\n                    lastFieldValue = b.substr(endOfBoundaryHeader);\n                    req->setBodyParam(lastFieldKey, lastFieldValue, boundaryContentType, false);\n                }\n            }\n            else {\n                throw Server::Exception(\"Unsupported body type: \" + contentType);\n            }\n        }\n    }\n    catch (const Server::Exception&) {\n        throw;\n    }\n    catch (const std::exception& e) {\n        throw Server::Exception(\"Error on parsing request: \" + std::string(e.what()));\n    }\n    return req;\n}\n\nServer::Server(int port) : port_(port) {\n#ifdef _WIN32\n    WSADATA wsa_data;\n    int initializeResult = WSAStartup(MAKEWORD(2, 2), &wsa_data);\n    if (initializeResult != 0) {\n        throw Exception(\"Error: WinSock WSAStartup failed: \" +\n                        string(getSocketError()));\n    }\n#endif\n\n    notFoundHandler_ = new NotFoundHandler();\n\n    sc_ = socket(AF_INET, SOCK_STREAM, 0);\n    int sc_option = 1;\n\n#ifdef _WIN32\n    setsockopt(sc_, SOL_SOCKET, SO_REUSEADDR, (char*)&sc_option, sizeof(sc_option));\n#else\n    setsockopt(sc_, SOL_SOCKET, SO_REUSEADDR, &sc_option, sizeof(sc_option));\n#endif\n    if (!ISVALIDSOCKET(sc_)) {\n        throw Exception(\"Error on opening socket: \" + string(getSocketError()));\n    }\n\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = INADDR_ANY;\n    serv_addr.sin_port = htons(port_);\n\n    if (::bind(sc_, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) != 0) {\n        throw Exception(\"Error on binding: \" + string(getSocketError()));\n    }\n}\n\nvoid Server::mapRequest(const string& path, RequestHandler* handler, Request::Method method) {\n    Route* route = new Route(method, path);\n    route->setHandler(handler);\n    routes_.push_back(route);\n}\n\nvoid Server::get(const std::string& path, RequestHandler* handler) {\n    mapRequest(path, handler, Request::Method::GET);\n}\n\nvoid Server::post(const std::string& path, RequestHandler* handler) {\n    mapRequest(path, handler, Request::Method::POST);\n}\n\nvoid Server::put(const std::string& path, RequestHandler* handler) {\n    mapRequest(path, handler, Request::Method::PUT);\n}\n\nvoid Server::del(const std::string& path, RequestHandler* handler) {\n    mapRequest(path, handler, Request::Method::DEL);\n}\n\nvoid Server::run() {\n    ::listen(sc_, 10);\n\n    struct sockaddr_in cli_addr;\n    socklen_t clilen;\n    clilen = sizeof(cli_addr);\n    SOCKET newsc;\n\n    while (true) {\n        newsc = ::accept(sc_, (struct sockaddr*)&cli_addr, &clilen);\n        if (!ISVALIDSOCKET(newsc))\n            throw Exception(\"Error on accept: \" + string(getSocketError()));\n        Response* res = nullptr;\n        try {\n            char* data = new char[BUFSIZE + 1];\n            size_t recv_len, recv_total_len = 0;\n            Request* req = nullptr;\n            while (!req) {\n                recv_len = recv(newsc, data + recv_total_len, BUFSIZE - recv_total_len, 0);\n                if (recv_len > 0) {\n                    recv_total_len += recv_len;\n                    data[recv_total_len >= 0 ? recv_total_len : 0] = 0;\n                    req = parseRawReq(data, recv_total_len);\n                }\n                else\n                    break;\n            }\n            delete[] data;\n            if (!recv_total_len) {\n                CLOSESOCKET(newsc);\n                continue;\n            }\n            req->log();\n            size_t i = 0;\n            for (; i < routes_.size(); i++) {\n                if (routes_[i]->isMatch(req->getMethod(), req->getPath())) {\n                    res = routes_[i]->handle(req);\n                    break;\n                }\n            }\n            if (i == routes_.size() && notFoundHandler_) {\n                res = notFoundHandler_->callback(req);\n            }\n            delete req;\n        }\n        catch (const Exception& exc) {\n            delete res;\n            res = ServerErrorHandler::callback(exc.getMessage());\n        }\n        res->log();\n        string res_data = res->getResponse();\n        int si = res_data.size();\n        delete res;\n        int wr = send(newsc, res_data.c_str(), si, 0);\n        if (wr != si)\n            throw Exception(\"Send error: \" + string(getSocketError()));\n        CLOSESOCKET(newsc);\n    }\n}\n\nServer::~Server() {\n    if (sc_ >= 0) {\n        CLOSESOCKET(sc_);\n    }\n    delete notFoundHandler_;\n    for (size_t i = 0; i < routes_.size(); ++i) {\n        delete routes_[i];\n    }\n#ifdef _WIN32\n    WSACleanup();\n#endif\n}\n\nServer::Exception::Exception(const string message) : message_(message) {}\n\nstring Server::Exception::getMessage() const { return message_; }\n\nShowFile::ShowFile(const string& filePath, const string& fileType)\n    : filePath_(filePath),\n      fileType_(fileType) {}\n\nResponse* ShowFile::callback(Request* req) {\n    Response* res = new Response();\n    res->setHeader(\"Content-Type\", fileType_);\n    res->setBody(utils::readFile(filePath_));\n    return res;\n}\n\nShowPage::ShowPage(const string& filePath)\n    : ShowFile(filePath, \"text/\" + utils::getExtension(filePath)) {}\n\nShowImage::ShowImage(const string& filePath)\n    : ShowFile(filePath, \"image/\" + utils::getExtension(filePath)) {}\n\nvoid Server::setNotFoundErrPage(const std::string& notFoundErrPage) {\n    delete notFoundHandler_;\n    notFoundHandler_ = new NotFoundHandler(notFoundErrPage);\n}\n\nRequestHandler::~RequestHandler() {}\n\nTemplateHandler::TemplateHandler(const string& filePath)\n    : filePath_(filePath),\n      parser_(new TemplateParser(filePath)) {}\n\nTemplateHandler::~TemplateHandler() {\n    delete parser_;\n}\n\nResponse* TemplateHandler::callback(Request* req) {\n    map<string, string> context;\n    context = this->handle(req);\n    Response* res = new Response();\n    res->setHeader(\"Content-Type\", \"text/html\");\n    res->setBody(parser_->getHtml(context));\n    return res;\n}\n\nmap<string, string> TemplateHandler::handle(Request* req) {\n    map<string, string> context;\n    return context;\n}\n","filename":"/Users/mahdis/Desktop/AP/AP6/server/server.cpp","identifier":"Text Change","lineCount":392,"languageId":"cpp"},"failed":false}